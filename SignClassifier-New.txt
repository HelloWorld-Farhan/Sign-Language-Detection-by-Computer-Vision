package com.yourpackage.islvision;

import android.content.Context;
import android.content.res.AssetFileDescriptor;
import android.graphics.Bitmap;
import android.util.Log;

import org.tensorflow.lite.Interpreter;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.List;

public class SignLanguageClassifier {
    private static final String TAG = "ISL_Classifier";
    private static final String MODEL_NAME = "isl_ultimate_90.tflite";
    private static final String LABELS_FILE = "labels.txt";
    private static final int IMG_SIZE = 224;
    private static final int BYTES_PER_CHANNEL = 4;
    private static final int NUM_CLASSES = 26;

    private Interpreter tflite;
    private List<String> labels;

    public SignLanguageClassifier(Context context) {
        try {
            // ‚úÖ FIXED: Removed GPU code to prevent crash
            Interpreter.Options options = new Interpreter.Options();
            options.setNumThreads(4);
            Log.d(TAG, "‚öôÔ∏è Using CPU with 4 threads");

            tflite = new Interpreter(loadModelFile(context), options);
            labels = loadLabels(context);

            Log.d(TAG, "‚úÖ Model loaded successfully");
            Log.d(TAG, "üìä Classes: " + labels.size());

        } catch (Exception e) {
            Log.e(TAG, "‚ùå Error loading model", e);
            throw new RuntimeException("Classifier initialization failed", e);
        }
    }

    private MappedByteBuffer loadModelFile(Context context) throws IOException {
        AssetFileDescriptor fileDescriptor = context.getAssets().openFd(MODEL_NAME);
        FileInputStream inputStream = new FileInputStream(fileDescriptor.getFileDescriptor());
        FileChannel fileChannel = inputStream.getChannel();
        long startOffset = fileDescriptor.getStartOffset();
        long declaredLength = fileDescriptor.getDeclaredLength();
        return fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength);
    }

    private List<String> loadLabels(Context context) throws IOException {
        List<String> labels = new ArrayList<>();
        BufferedReader reader = new BufferedReader(
                new InputStreamReader(context.getAssets().open(LABELS_FILE))
        );
        String line;
        while ((line = reader.readLine()) != null) {
            labels.add(line.trim());
        }
        reader.close();
        Log.d(TAG, "‚úÖ Loaded " + labels.size() + " labels");
        return labels;
    }

    public Result classify(Bitmap bitmap) {
        if (tflite == null || bitmap == null) {
            Log.e(TAG, "‚ùå Model or bitmap is null");
            return new Result("Error", 0.0f, new float[NUM_CLASSES]);
        }

        try {
            long startTime = System.currentTimeMillis();

            Bitmap resizedBitmap = Bitmap.createScaledBitmap(bitmap, IMG_SIZE, IMG_SIZE, true);

            ByteBuffer inputBuffer = ByteBuffer.allocateDirect(
                    BYTES_PER_CHANNEL * IMG_SIZE * IMG_SIZE * 3
            );
            inputBuffer.order(ByteOrder.nativeOrder());

            int[] pixels = new int[IMG_SIZE * IMG_SIZE];
            resizedBitmap.getPixels(pixels, 0, IMG_SIZE, 0, 0, IMG_SIZE, IMG_SIZE);

            for (int pixel : pixels) {
                int r = (pixel >> 16) & 0xFF;
                int g = (pixel >> 8) & 0xFF;
                int b = pixel & 0xFF;

                inputBuffer.putFloat(r / 255.0f);
                inputBuffer.putFloat(g / 255.0f);
                inputBuffer.putFloat(b / 255.0f);
            }

            float[][] output = new float[1][NUM_CLASSES];
            tflite.run(inputBuffer, output);

            float[] probabilities = output[0];

            int maxIndex = 0;
            float maxProb = probabilities[0];
            for (int i = 1; i < NUM_CLASSES; i++) {
                if (probabilities[i] > maxProb) {
                    maxProb = probabilities[i];
                    maxIndex = i;
                }
            }

            long inferenceTime = System.currentTimeMillis() - startTime;

            String predictedLabel = labels.get(maxIndex);
            Result result = new Result(predictedLabel, maxProb, probabilities);

            Log.d(TAG, String.format("‚ö° Inference: %dms | Predicted: %s (%.1f%%)",
                    inferenceTime, predictedLabel, maxProb * 100));

            if (resizedBitmap != bitmap) {
                resizedBitmap.recycle();
            }

            return result;

        } catch (Exception e) {
            Log.e(TAG, "‚ùå Error during classification", e);
            return new Result("Error", 0.0f, new float[NUM_CLASSES]);
        }
    }

    public void close() {
        if (tflite != null) {
            tflite.close();
            tflite = null;
        }
        Log.d(TAG, "üîí Classifier closed");
    }

    public static class Result {
        private String label;
        private float confidence;
        private float[] allProbabilities;

        public Result(String label, float confidence, float[] allProbabilities) {
            this.label = label;
            this.confidence = confidence;
            this.allProbabilities = allProbabilities;
        }

        public String getLabel() {
            return label;
        }

        public float getConfidence() {
            return confidence;
        }

        public int getConfidencePercent() {
            return Math.round(confidence * 100);
        }

        public float[] getAllProbabilities() {
            return allProbabilities;
        }
    }
}